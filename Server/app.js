// Generated by CoffeeScript 1.12.6
(function() {
  var PORT, PUBLIC, WS, _on_time, app, express, http, multicast, server, wss;

  http = require('http');

  express = require('express');

  WS = require('ws').Server;

  PUBLIC = __dirname + '/public/';

  PORT = process.env.PORT || 3000;

  app = express();

  server = http.createServer(app);

  wss = new WS({
    server: server,
    perMessageDeflate: false,
  });

  var connections = [];
  var numberChannels = {};
  var hasStarted = {};
  var lobbyState = {};

  app.use(express["static"](PUBLIC));

// Handles everything for each connection
  wss.on('connection', function(ws, req) {
    console.log('Connected ' + req.connection.remoteAddress);
    ws.id = req.connection.remoteAddress;
    ws.channel = 'global'
    ws.connected = true;

    if (numberChannels[ws.channel] == null) {
      numberChannels[ws.channel] = 0;
    }
    numberChannels[ws.channel] += 1;

    connections.push(ws);
    var pingpong = setInterval(ping, 20000);
    console.log(numberChannels[ws.channel] + ' clients in channel ' + ws.channel);

    // Activated when receiving a message from a connection
    ws.onmessage = function(event) {
      var dict;
      console.log(ws.id + ' : ' + event.data);
      try{
		dict = JSON.parse(event.data);
		switch (dict.event) {

        case 'pong':
          pong();
          break;

        case 'update':
          multicast(event.data, ws);
          break;

        case 'join':
          if (hasStarted[dict.channel] != true) {
            join(ws, dict.channel, dict.role);
          } else {
            try {
              ws.send('{"event":"error","msg":"game_started"}');
            } catch (e) {
              console.log("Failed to send");
            }
          }
          break;

        case 'leave':
          if (ws.channel != 'global') {
            leave(ws, ws.role);
          }
          break;

        case 'multicast':
          multicast(event.data, ws);
          break;

        case 'global':
          global_chan(ws);
          break;

        case 'broadcast':
          broadcast(event.data, ws);
          break;

        case 'channel':
          change_channel(ws, dict.channel);
          break;

        case 'connection':
          // ws.id = dict.id;
          console.log('New id: ' + ws.id);
          try {
            ws.send('{"event":"ack"}');
          } catch (e) {
            console.log("Failed to send");
          }
          break;

        case 'add_room':
          console.log('add_room');
          multicast(event.data, ws);
          break;

        case 'reconnection':
          ws.id = dict.id;
          console.log('Reconnection id: ' + ws.id);
          is_double(ws);
          break;

        default:
          console.log('Event non reconnu : ' + dict.event);
      }
		} catch(err){
		console.log('something horribly bad happened when trying to parse');}
    };

    // Activated when an error is happening
    ws.onerror = function(error) {
      return console.log(error);
    };

    // Activated when a connection is closed
    ws.onclose = function(code, reason) {

      clearInterval(pingpong);

      ws.connected = false;

      var channel = ws.channel;
      numberChannels[channel] -= 1;
      console.log(ws.id + ' has left channel ' + channel);

      if (channel != 'global' && hasStarted[channel] != true) {
        lobbyState[ws.channel] -= ws.role;
      }

      if (hasStarted[channel] == true) {
        console.log(ws.id + ' has been disconnected during a game');
        hold_connection(ws);
        return
      }
      var index = connections.indexOf(ws);
      connections.splice(index, 1);

      return console.log(ws.id + ' has been disconnected');
    };

    function ping() {
      try {
        ws.send('{"event":"ping"}');
      } catch(e) {
        console.log('Could not send ping to ' + ws.id);
      }
      /*
      tm = setTimeout(function () {
        console.log(ws.id + ' timed out');
        ws.close(42, 'Duh');
        clearInterval(pingpong);
        clearTimeout(tm);

        ws.connected = false;

        var channel = ws.channel;
        numberChannels[channel] -= 1;
        console.log(ws.id + ' has left channel ' + channel);

        if (channel != 'global' && hasStarted[channel] != true) {
          lobbyState[ws.channel] -= ws.role;
        }

        if (hasStarted[channel] == true) {
          console.log(ws.id + ' has been disconnected during a game');
          hold_connection(ws);
          return
        }
        var index = connections.indexOf(ws);
        connections.splice(index, 1);

        return console.log(ws.id + ' has been disconnected');
      }, 1000);
      */
    }

    function pong() {
      console.log("Received pong");
      //clearTimeout(tm);
    }

    return
  });

  server.listen(PORT, process.env.IP || "0.0.0.0", function() {
    return console.log("Server started");
  });

  // Function to multicast (broadcast to a channel) a message
  function multicast (message, ws) {
    var channel = ws.channel;
    var id = ws.id;
    for (var i=0; i<connections.length; i++) {
      if (connections[i].id != id && connections[i].channel == channel) {
        console.log('multicasting');
        try {
          connections[i].send(message);
        } catch (e) {
          console.log("Failed to send");
        }
      }
    }
  }

  // Function to send a message to everyone on a channel
  function server_multicast(channel, msg) {
    for (var i=0; i<connections.length; i++) {
      if (connections[i].channel == channel) {
        try {
          connections[i].send(msg);
        } catch (e) {
          console.log("Failed to send");
        }
      }
    }
  }

  // Function to broadcast a message
  function broadcast(message, ws) {
  var channel = ws.channel;
  var id = ws.id;
    for (var i=0; i<connections.length; i++) {
      if (connections[i].id != ws.id) {
        try {
          connections[i].send(message);
        } catch (e) {
          console.log("Failed to send");
        }
      }
    }
  }

  // Function to change channel
  function change_channel(ws, channel) {

    if (ws.channel == channel) {
      return
    }

    if (channel != 'global' && numberChannels[channel] >= 2) {
      console.log('Too many clients in channel ' + channel);
      try {
        ws.send('{"event":"error","msg":"clients_overflow"}');
      } catch (e) {
        console.log("Failed to send");
      }
      return
    }

    numberChannels[ws.channel] -= 1;
    console.log(ws.id + ' has left channel ' + ws.channel);
    console.log(numberChannels[ws.channel] + ' clients in channel ' + ws.channel);

    ws.channel = channel;
    if (numberChannels[channel] == null) {
      numberChannels[channel] = 0;
    }
    numberChannels[channel] += 1;
    try {
      ws.send('{"event":"channel", "channel":"' + channel + '"}');
    } catch (e) {
      console.log("Failed to send");
    }
    console.log(ws.id + ' has joined channel ' + channel);
    console.log(numberChannels[channel] + ' clients in channel ' + channel);
  }

  // Function to free a channel
  function global_channel(channel) {
    for (var i=0; i<connections.length; i++) {
      if (connections[i].channel == channel) {
        change_channel(connections[i], 'global');
      }
    }
    console.log('Freed channel ' + channel);
  }

  // Function to move a client to the global channel
  function global_chan(ws) {
    change_channel(ws, 'global');
  }

  // Function to start a game and block the channel
  function start(channel) {
    hasStarted[channel] = true;
    server_multicast(channel,'{"event":"start"}');
    console.log("Game on channel " + channel + " has started");
    /*var timer = 5;
    var interval = setInterval(function countdown() {
      timer -= 1;
      if (timer <= 0) {
        clearInterval(interval);
        end(channel);
      }
    }, 1000);*/
  }

  // Function to end a game and free the channel
  function end(channel) {
    hasStarted[channel] = false;
    lobbyState[channel] = 0;
    server_multicast(channel, '{"event":"end"}');
    global_channel(channel);
    console.log("Game on channel " + channel + " has ended");
  }

  // Function to make a client join a lobby
  function join(ws, channel, role) { // Role: 1 for Hero, 2 for Architect
    console.log(lobbyState[channel] + ': lobbyState');
    switch(lobbyState[channel]) {

      case null:
        lobbyState[channel] = parseInt(role);
        change_channel(ws, channel);
        ws.role = role;
        if (role == 1) {
          console.log('A hero has joined lobby ' + channel);
        }
        if (role == 2) {
          console.log('An architect has joined lobby ' + channel);
        }
        break;

      case undefined:
        lobbyState[channel] = parseInt(role);
        change_channel(ws, channel);
        ws.role = role;
        if (role == 1) {
          console.log('A hero has joined lobby ' + channel);
        }
        if (role == 2) {
          console.log('An architect has joined lobby ' + channel);
        }
        break;

      case 0:
        lobbyState[channel] = parseInt(role);
        change_channel(ws, channel);
        ws.role = role;
        if (role == 1) {
          console.log('A hero has joined lobby ' + channel);
        }
        if (role == 2) {
          console.log('An architect has joined lobby ' + channel);
        }
        break;

      case 1:
        if (role == 1) {
          try {
            ws.send('{"event":"error","msg":"hero"}');
          } catch (e) {
            console.log("Failed to send");
          }
          console.log('Already a hero');
        } else {
          lobbyState[channel] = 3;
          change_channel(ws, channel);
          ws.role = role;
          console.log('An architect has joined lobby ' + channel);
          check_start(channel);
        }
        break;

      case 2:
        if (role == 2) {
          try {
            ws.send('{"event":"error","msg":"architect"}');
          } catch (e) {
            console.log("Failed to send");
          }
          console.log('Already an architect');
        } else {
          lobbyState[channel] = 3;
          change_channel(ws, channel);
          ws.role = role;
          console.log('A hero has joined lobby ' + channel);
          check_start(channel);
        }
        break;

      case 3:
        try {
          ws.send('{"event":"error","msg":"full"}');
        } catch (e) {
          console.log("Failed to send");
        }
        break;

      default:
        console.log('Unknown lobbystate detected from : ' + ws.id);
    }
  }

  // Function to make a client leave a lobby
  function leave(ws, role) {
    lobbyState[ws.channel] -= role;
    if (role == 1) {
      console.log('A hero has left lobby ' + ws.channel);
    } else {
      console.log('An architect has left lobby ' + ws.channel);
    }
    global_chan(ws);
  }

  // Function to check if a game can be launched and begins a countdown if possible
  function check_start(channel) {
    if (lobbyState[channel] == 3) {
      server_multicast(channel, '{"event":"soon"}');

      var timer = 5;

      var interval = setInterval(function countdown() {
        timer -= 1;
        if (timer <= 0) {
          clearInterval(interval);
          start(channel);
        }
      }, 1000);

    }
  }

  // Function to hold a game when a player has been disconnected
  function hold_connection(ws) {
    multicast('{"event":"error","msg":"disconnection"}', ws);

    var timer = 10;

    var interval = setInterval(function countdown() {
      timer -= 1;
      if (ws.connected == true) {
        var index = connections.indexOf(ws);
        connections.splice(index, 1);
        return
      }
      if (timer <= 0) {
        clearInterval(interval);
        console.log('Game in channel ' + ws.channel + " can't continue");
        var index = connections.indexOf(ws);
        connections.splice(index, 1);
        end(ws.channel);
      }

    }, 1000);
  }

  // Function to check if a connection was already there when reconnecting
  function is_double(web) {
    for (i=0; i<connections.length; i++) {
      var co = connections[i];
      if (co.id == web.id) {
        co.connected = true;
        change_channel(web, co.channel);
        web.role = 3 - lobbyState[co.channel];
        lobbyState[co.channel] = 3;
        server_multicast(co.channel, '{"event":"error","msg":"reconnection"}');
        log.console(web.id + ' has reconnected');
        return
      }
    }
    try {
      web.send('{"event":"error","msg":"reconnection"}');
    } catch (e) {
      console.log("Failed to send");
    }
    log.console('Could not reconnect ' + web.id);
  }

  _free_channels = function() {
    for (var channel in numberChannels) {
      if (numberChannels[channel] == 0) {
        delete numberChannels[channel];
        delete lobbyState[channel];
        delete hasStarted[channel];
      }
    }
  };

  setInterval(_free_channels, 60000);

}).call(this);
