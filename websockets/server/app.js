// Generated by CoffeeScript 1.12.6
(function() {
  var PORT, PUBLIC, WS, _on_time, app, express, http, multicast, server, wss;

  http = require('http');

  express = require('express');

  WS = require('ws').Server;

  PUBLIC = __dirname + '/public/';

  PORT = process.env.PORT || 3000;

  app = express();

  server = http.createServer(app);

  wss = new WS({
    server: server,
    perMessageDeflate: false
  });

  var connections = [];
  var numberChannels = {};
  var hasStarted = {};
  var lobbyState = {};

  app.use(express["static"](PUBLIC));

// Handles everything for each connection
  wss.on('connection', function(ws, req) {
    console.log('Connected ' + req.connection.remoteAddress);
    ws.id = req.connection.remoteAddress;
    ws.channel = 'global'

    if (numberChannels[ws.channel] == null) {
      numberChannels[ws.channel] = 0;
    }
    numberChannels[ws.channel] += 1;

    connections.push(ws);
    console.log(numberChannels[ws.channel] + ' clients in channel ' + ws.channel);

    ws.onmessage = function(event) {
      var dict;
      console.log(event.data);
      dict = JSON.parse(event.data);

      switch (dict.event) {

        case 'multicast':
          multicast(event.data, ws);
          break;

        case 'broadcast':
          broadcast(event.data, ws);

        case 'channel':
          change_channel(ws, dict.channel);
          break;

        case 'global':
          global_chan(ws);
          break;

        case 'update':
          multicast(event.data, ws);
          break;

        case 'join':
          if (hasStarted[dict.channel] != true) {
            join(ws, dict.channel, dict.role);
          } else {
            ws.send('{"event":"error","msg":"game_started"}');
          }
          break;

        case 'leave':
          leave(ws, role);
          break;

        default:
          console.log('Event non reconnu');
      }
    };

    ws.onerror = function(error) {
      return console.log(error);
    };

    ws.onclose = function(code, reason) {
      var channel = ws.channel;
      numberChannels[channel] -= 1;
      console.log(ws.id + ' has left channel ' + channel);
      if (channel != global && hasStarted[channel] != false) {
        lobbyState[ws.channel] -= ws.role;
      }
      connections.splice(ws);
      return console.log(req.connection.remoteAddress + ' has been disconnected');
    };

    return ws.send('Logged');
  });

  server.listen(PORT, process.env.IP || "0.0.0.0", function() {
    return console.log("Server started");
  });

  // Function to multicast (broadcast to a channel) a message
  function multicast (message, ws) {
    var channel = ws.channel;
    var id = ws.id;
    for (var i=0; i<connections.length; i++) {
      if (connections[i].id != id && connections.channel == channel) {
        connections[i].send(message);
      }
    }
  }

  // Function to send a message to everyone on a channel
  function server_multicast(channel, msg) {
    for (var i=0; i<connections.length; i++) {
      if (connections[i].channel == channel) {
        connections[i].send(msg);
      }
    }
  }

  // Function to broadcast a message
  function broadcast(message, ws) {
  var channel = ws.channel;
  var id = ws.id;
    for (var i=0; i<connections.length; i++) {
      if (connections[i].id != ws.id) {
        connections[i].send(message);
      }
    }
  }

  // Function to change channel
  function change_channel(ws, channel) {

    if (ws.channel == channel) {
      return
    }

    if (channel != global && numberChannels[channel] >= 2) {
      console.log('Too many clients in channel ' + channel);
      ws.send('{"event":"error","msg":"clients_overflow"}');
      return
    }

    numberChannels[ws.channel] -= 1;
    console.log(ws.id + ' has left channel ' + ws.channel);
    console.log(numberChannels[ws.channel] + ' clients in channel ' + ws.channel);

    ws.channel = channel;
    if (numberChannels[channel] == null) {
      numberChannels[channel] = 0;
    }
    numberChannels[channel] += 1;
    ws.send('{"event":"channel", "channel":' + channel + '}')
    console.log(ws.id + ' has joined channel ' + channel);
    console.log(numberChannels[channel] + ' clients in channel ' + channel);

    if (numberChannels[channel] == 2) {
      start(channel);
    }
  }

  // Function to free a channel
  function global_channel(channel) {
    for (var i=0; i<connections.length; i++) {
      if (connections[i].channel == channel) {
        change_channel(connections[i], global);
      }
    }
    console.log('Freed channel ' + channel);
  }

  // Function to move a client to the global channel
  function global_chan(ws) {
    change_channel(ws, global);
  }

  // Function to start a game and block the channel
  function start(channel) {
    hasStarted[channel] = true;
    server_multicast(channel,'{"event":"start"}');
    console.log("Game on channel " + channel + " has started");
  }

  // Function to end a game and free the channel
  function end(channel) {
    hasStarted[channel] = false;
    server_multicast(channel, '{"event":"end"}');
    console.log("Game on channel " + channel + "has started");
  }

  // Function to make a client join a lobby
  function join(ws, channel, role) { // Role: 1 for Hero, 2 for Architect
    switch(lobbyState[channel]) {

      case null:
        lobbyState[channel] = role;
        change_channel(ws, channel);
        ws.role = role;
        break;

      case undefined:
        lobbyState[channel] = role;
        change_channel(ws, channel);
        ws.role = role;
        break;

      case 0:
        lobbyState[channel] = role;
        change_channel(ws, channel);
        break;

      case 1:
        if (role == 1) {
          ws.send('{"event":"error","msg":"hero"}');
          console.log('Already a hero');
        } else {
          lobbyState[channel] = 3;
          change_channel(ws, channel);
          ws.role = role;
          console.log('An architect has joined lobby ' + channel);
        }
        break;

      case 2:
        if (role == 2) {
          ws.send('{"event":"error","msg":"architect"}');
          console.log('Already an architect');
        } else {
          lobbyState[channel] = 3;
          change_channel(ws, channel);
          ws.role = role;
          console.log('A hero has joined lobby ' + channel);
        }
        break;

      case 3:
        ws.send('{"event":"error","msg":"full"}')
        break;

      default:
        console.log('Unknown lobbystate detected from : ' + ws.id);
    }
  }

  // Function to make a client leave a lobby
  function leave(ws, role) {
    lobbyState[ws.channel] -= role;
    global_chan(ws);
  }

/*
  _on_time = function() {
    var msg;
    msg = new Date().toString();
    return wss.clients.forEach((function(_this) {
      return function(client) {
        var err;
        try {
          return client.send(msg);
        } catch (error1) {
          err = error1;
          return err;
        }
      };
    })(this));
  };

  setInterval(_on_time, 3000);
  */

  _free_channels = function() {
    for (var channel in numberChannels) {
      if (numberChannels[channel] == 0) {
        delete numberChannels[channel];
      }
    }
  };

  setInterval(_free_channels, 60000);

}).call(this);
